#include <iostream>
#include <sstream>
#include <thread>
#include <vector>

////////////////////////////////////////////////////////////////////////////////

void test1_thread() {
  std::cout << "Testing threads..." << std::endl;

  /*
    Программа, работая, может произвольно запускать поток из любого своего
    потока.

    В качестве "корня" потока (по аналогии с функцией main) можно использовать
    ламбду, просто функцию, любой callable объект.

  */
  const auto worker = [](const int number, const std::string& str) {
    /*
      Аргументы скопированы в стек нового потока, а затем переданы как r-values.
      Даже если у функции потока в аргументах ссылка.
      Но можно использовать std::ref и передать их по ссылке.
     */

    for (int i = 0; i < 10; ++i) {
      // Для наглядности теста сформируем вывод в cout "одним куском":
      std::cout << (str + " Hello from thread number: " +
                    std::to_string(number) + "\n");
    }

    /*
      Возвращаемое функцией значение - игнорируется, но можно использовать
      std::promise и получить его.
     */
    return 123;
  };

  const std::string str = "ABC123";

  /*
    Потоки запускаются созданием объекта std::thread.

    Функция выполняется в собственном потоке, пока не вернет управление,
    после чего поток останавливается.
  */
  std::thread thread1(worker, 0, str);
  std::thread thread2(worker, 1, std::ref(str));

  /*
    Теперь выпоняемые потоки и поток, в котором мы сейчас, живут
    в разных "измерениях".

    Чтобы дождаться, пока поток завершится - вызывайте join. Метод join
    остановит выполение нашего потока до момента завершения ожидаемого потока.

    Если хотите отвязать объект потока от потока, тем самым оставив поток
    выполняться "в фонe" - вызывайте метод detach. После этого можно
    спокойно разрушать объект потока - он больше не влияет на поток.

    Если не вызвать ни того, ни другого, и объект std::thread будет уничтожен
    -  деструктор std::thread вызовет std::terminate. Это произойдёт даже если
    сам поток завершился до унитожения std::thread.

    Попробьуйте самостоятельно познакомиться с std::jthread из С++20
    - он выполняет join автоматически.

    Попробуйте закомментировать одну или две следущие строки и выход программы
    из области видомости объектов thread1 и/или thread2 аварийно завершит
    выполние программы.
   */
  thread1.detach();
  thread2.join();

  /*
    Необработанное исключение в потоке приводит к вызову std::terminate.

    Попробуйте разкомментировать код ниже, и он аварийно остановит
    работу программы.
   */
  /*
  std::thread bad_worker_thread(
    [](){ throw std::runtime_error("Bad working error") });
  bad_worker_thread.join();
  */

  std::cout << "Testing thread finished." << std::endl;

  // std::this_thread::sleep_for(std::chrono::milliseconds(500));
}

////////////////////////////////////////////////////////////////////////////////

void test2_methods() {
  std::cout << "Testing thread methods..." << std::endl;

  /*
    std::thread::hardware_concurrency() возвращает количество потоков,
    которые могут работать реально параллельно. Например, может быть связано
    с числом ядер центрального процессора. Может вернуть 0, если информация
    недоступна.

    Данный показатель можно использовать, например, при определении оптимальных
    размеров пулов потоков. Но не стоить забывать, что ваша программа никогда
    не будет одна на компьютере.
  */
  auto concurrency = std::thread::hardware_concurrency();
  std::cout << "hardware_concurrency = " << concurrency << std::endl;
  if (!concurrency) {
    concurrency = 2;
  }

  const auto worker = []() {
    std::ostringstream ss;
    /*
     std::this_thread::get_id() возвращает ID потока. Можно использовать
     для лога, или в качестве ключа ассоциативного контейнера потоков.
    */
    ss << "Hello from thread with ID " << std::this_thread::get_id() << "\n";
    std::cout << ss.str();
  };

  std::vector<std::thread> threads;
  for (std::size_t i = 0; i < concurrency; ++i) {
    threads.emplace_back(worker);
  }

  for (auto& th : threads) {
    if (th.joinable()) {
      th.join();
    }
  }

  std::cout << "Testing thread methods finished." << std::endl;
}

////////////////////////////////////////////////////////////////////////////////

int main() {
  /*
    В любом процессе уже есть _минимум_ 1 поток, который запускается
    автоматически.

    Сейчас, находясь в main, мы уже находимся в этом потоке.

    Этот поток будет активен всё время жизни приложение и завершится при выходе
    из main, ожидаемо или из-за исключительной ситуации.

    Завершение процесса программы принудительно "убъёт" все остальные потоки
    программы, не дожидаясь ничего. Просто в том месте где они сейчас находтся
    в процессе свого выполнения.
  */
  std::cout << R"(Hello! This is "main" thread!)" << std::endl;
  std::cout << std::endl;

  test1_thread();

  std::cout << std::endl
            << "##############################################################"
            << std::endl
            << std::endl;

  test2_methods();

  return 0;
}

////////////////////////////////////////////////////////////////////////////////